<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>DOM</title>
</head>
<body>
<script>
//    someNode.nodeType ==
    //节点类型
//    Node.ELEMENT_NODE(1);//元素节点
//    Node.ATTRIBUTE_NODE(2);
//    Node.TEXT_NODE(3);
//    Node.CDATA_SECTION_NODE(4);
//    Node.ENTITY_REFERENCE_NODE(5);
//    Node.ENTITY_NODE(6);
//    Node.PROCESSING_INSTRUCTION_NODE(7);
//    Node.COMMENT_NODE(8);
//    Node.DOCUMENT_NODE(9);
//    Node.DOCUMENT_TYPE_NODE(10);
//    Node.DOCUMENT_FRAGMENT_NODE(11);
//    Node.NOTATION_NODE(12);


//1. nodeName 和 nodeValue 属性
//2. 节点关系 childNodes NodeList数组

    getAttribute();
    setAttribute();
    removeAttribute();

    document.createElement();
    appendChild();
    insertBefore();
    replaceChild();

    div.classList.add("user");
div.classList.contains("user");//表示列表中是否存在给定的值，如果存在则返回 true，否则返回 false。
div.classList.remove("user");
div.classList.toggle("user");//如果列表中已经存在给定的值，删除它；如果列表中没有给定的值，添加它。这样，前面那么多行代码用下面这一行代码就可以代替了：

document.activeElement//属性始终会引用 DOM 中当前获得了焦点的元素 (页面首次加载获取的是body)
document.readyState();//loading，正在加载文档；complete，已经加载完文档。

dataset //(获取自定义属性data-)
//"beforebegin"，在当前元素之前插入一个紧邻的同辈元素；
//"afterbegin"，在当前元素之下插入一个新的子元素或在第一个子元素之前再插入新的子元素；
//"beforeend"，在当前元素之下插入一个新的子元素或在最后一个子元素之后再插入新的子元素；
//"afterend"，在当前元素之后插入一个紧邻的同辈元素。
document.querySelector("#submit").insertAdjacentHTML("afterend","<p>我是插入的h</p>");

    contains()//元素的包含
scrollIntoView()//true滚动到最上top
document.querySelector("元素").scrollIntoViewIfNeeded(true);//滚动到制定元素  Safari 和 Chrome 实现了这个方法
</script>
</body>
</html>